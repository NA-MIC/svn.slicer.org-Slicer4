#=auto==========================================================================
#   Portions (c) Copyright 2007 Brigham and Women's Hospital (BWH) All Rights Reserved.
# 
#   See Doc/copyright/copyright.txt
#   or http://www.slicer.org/copyright/copyright.txt for details.
# 
#   Program:   3D Slicer
#   Module:    $RCSfile: TumorGrowthFct.tcl,v $
#   Date:      $Date: 2007/12/12 15:07:28 $
#   Version:   $Revision: 1.9 $
# 
#===============================================================================

proc TumorGrowthInit_Fct {} {

    global TumorGrowth Volume

    # Not hte nicest way - but I do not care right now 
    package require vtkEMPrivateSegment
    package require vtkITK
    package require vtkAG


    # Initialize module-level variables
    #------------------------------------
    # Description:
    #   Keep a global array with the same name as the module.
    #   This is a handy method for organizing the global variables that
    #   the procedures in this module and others need to access.
    #

    set TumorGrowth(Scan1) $Volume(idNone)
    set TumorGrowth(Scan1,Max,X) -1 
    set TumorGrowth(Scan1,Max,Y) -1 
    set TumorGrowth(Scan1,Max,Z) -1 
    set TumorGrowth(Scan1,Threshold) 0
    catch {TumorGrowth(Scan1,ROI) Delete}
    catch {TumorGrowth(Scan1,ROISuperSample) Delete}


    set TumorGrowth(NumSteps) 5   
    set TumorGrowth(Scan2) $Volume(idNone)
    set TumorGrowth(ROI,TaskList) "Sample Show Reset OK" 
    set TumorGrowth(ROI,SampleButton) 0 
    set TumorGrowth(ROI,ShowButton) 0 
    set TumorGrowth(ROI,id) ""

    set TumorGrowth(Scan1,ROISuperSample) 0.0
    set TumorGrowth(Scan1,ROISuperSample,id) $Volume(idNone)
    set TumorGrowth(Scan2,ROISuperSample,id) $Volume(idNone)

    set TumorGrowth(Scan2,GlobalRegistration) "" 
    set TumorGrowth(Scan2,LocalRegistration) "" 

    TumorGrowthROIInitialize
    set TumorGrowth(Scan1,PreSegment,id) $Volume(idNone)
    set TumorGrowth(Scan1,Segment,id) $Volume(idNone)

    set TumorGrowth(Scan2ToScan1,Global,id) $Volume(idNone)
    set TumorGrowth(Scan2ToScan1,Global,Transform) ""

    set TumorGrowth(Scan2ToScan1,Local,id) $Volume(idNone)
    set TumorGrowth(Scan2ToScan1,Local,Transform) ""

    set TumorGrowth(Scan2,ROISuperSampleNormalized,id) $Volume(idNone)

    set TumorGrowth(Scan1,ROIThreshold,id) $Volume(idNone)
    set TumorGrowth(Scan2,ROIThreshold,id) $Volume(idNone)

    set TumorGrowth(FinalAnalysis,id) $Volume(idNone)

    set TumorGrowth(TransformIndex) 0

    set TumorGrowth(save,Dir) ""
    set TumorGrowth(save,ScanOrder) ""

    set TumorGrowth(save,ROI) 1

    set TumorGrowth(save,Segment) 1
    set TumorGrowth(save,Registration) 1
    set TumorGrowth(save,Threshold) 1
    set TumorGrowth(save,Normalization) 1
    set TumorGrowth(save,Final) 1

    set TumorGrowth(scan1,save,Name) scan1
    set TumorGrowth(scan2,save,Name) scan2


    # Step specific parameters 
    set TumorGrowth(Step4,IslandMinSize) 1000
    set TumorGrowth(Step5,RigidRegistrationType) "GCR L1 norm"

    set TumorGrowth(Step5,HistogramTypeList) "ITK Mean"
    set TumorGrowth(Step5,HistogramType) "Mean"

    set TumorGrowth(FinalAnalysisThreshold) 0.0 
    set TumorGrowth(ROI,SuperSampleVoxelVolume) 0.0
    set TumorGrowth(ROI,RatioNewOldSpacing) 0.0

    # AnalysisType can have two values 
    # INTENSITY  = Tumor growth analysis is based subtracting intensities (Kilian)
    # DEFORMABLE = Tumor growth analysis is based deformable model (Ender) 
    set TumorGrowth(AnalysisType) "INTENSITY"
    set TumorGrowth(AnalysisSensitivityValue) "0.5" 

}

proc TumorGrowthROIInitialize { } {

    global TumorGrowth
    set TumorGrowth(ROI,MinCoord,x) -1 
    set TumorGrowth(ROI,MinCoord,y) -1 
    set TumorGrowth(ROI,MinCoord,z) -1 
    set TumorGrowth(ROI,MaxCoord,x) -1 
    set TumorGrowth(ROI,MaxCoord,y) -1 
    set TumorGrowth(ROI,MaxCoord,z) -1 

    # CAHILL 
    set TumorGrowth(ROI,MinCoord,x) 135 
    set TumorGrowth(ROI,MinCoord,y) 60
    set TumorGrowth(ROI,MinCoord,z) 23 
    set TumorGrowth(ROI,MaxCoord,x) 163 
    set TumorGrowth(ROI,MaxCoord,y) 85
    set TumorGrowth(ROI,MaxCoord,z) 35 


    # SILVA CASE original
    # set TumorGrowth(ROI,MinCoord,x) 73
    # set TumorGrowth(ROI,MinCoord,y) 96
    # set TumorGrowth(ROI,MinCoord,z) 92
    # set TumorGrowth(ROI,MaxCoord,x) 91
    # set TumorGrowth(ROI,MaxCoord,y) 115
    # set TumorGrowth(ROI,MaxCoord,z) 105

    set TumorGrowth(ROI,MinCoord,x) 73
    set TumorGrowth(ROI,MinCoord,y) 90
    set TumorGrowth(ROI,MinCoord,z) 92
    set TumorGrowth(ROI,MaxCoord,x) 95
    set TumorGrowth(ROI,MaxCoord,y) 120
    set TumorGrowth(ROI,MaxCoord,z) 105



    set TumorGrowth(ROI,Size,x) 0
    set TumorGrowth(ROI,Size,y) 0
    set TumorGrowth(ROI,Size,z) 0

}

proc TumorGrowthImageDataWriter {ImageData Name} {
    global TumorGrowth

    set extents [$ImageData GetExtent]
    # Has to be defined otherwise it does not work - I do not know why 
    vtkMatrix4x4 export_matrix

    vtkMrmlVolumeNode blub
      eval blub SetImageRange "1 [expr [lindex $extents 5] - [lindex $extents 4] + 1]" 
      eval blub SetDimensions "[expr [lindex $extents 1] - [lindex $extents 0] + 1] [expr [lindex $extents 3] - [lindex $extents 2] + 1]" 
      eval blub SetSpacing    [$ImageData GetSpacing]
      blub ComputeRasToIjkFromScanOrder "$TumorGrowth(save,ScanOrder)"

    eval export_matrix DeepCopy [blub GetRasToIjkMatrix] 
    blub Delete


    catch {exec mkdir $TumorGrowth(save,Dir)}

    vtkITKImageWriter export_iwriter 
      export_iwriter SetInput $ImageData
      export_iwriter SetFileName $TumorGrowth(save,Dir)/${Name}.nhdr
	
      export_iwriter SetRasToIJKMatrix export_matrix 
      export_iwriter SetUseCompression 1
                      
      # Write volume data
      export_iwriter Write

    export_iwriter Delete
    export_matrix Delete 
    
}

proc TumorGrowthTextWriter {Name fileText} {
  global TumorGrowth
  set fileName $TumorGrowth(save,Dir)/${Name}.log 

  if {[catch {set fid [open $fileName w]} errmsg] == 1} {
    puts $errmsg
    return ""
  }

  puts $fid "$fileText"

  if {[catch {close $fid} errorMessage]} {
    puts "Aborting due to : ${errorMessage}"
  }
}


proc TumorGrowthROICheck { } {
 global TumorGrowth
 set MIN "$TumorGrowth(ROI,MinCoord,x) $TumorGrowth(ROI,MinCoord,y) $TumorGrowth(ROI,MinCoord,z)"
 set MAX "$TumorGrowth(ROI,MaxCoord,x) $TumorGrowth(ROI,MaxCoord,y) $TumorGrowth(ROI,MaxCoord,z)"

 set TumorGrowth(ROI,MinCoord,x) "-1"
 eval TumorGrowthROIUpdate $MIN
 set TumorGrowth(ROI,MaxCoord,x) "-1"
 eval TumorGrowthROIUpdate $MAX
}

proc TumorGrowthROIUpdate { x y z} {
    global TumorGrowth
    if { $x < 0 } { set x 0
    } else {
	if { $x > $TumorGrowth(Scan1,Max,X) } {set x $TumorGrowth(Scan1,Max,X) 
	} else { set x [expr int($x)] }
    }
    
    if {$y < 0 } { set y 0
    } else {
	if {$y > $TumorGrowth(Scan1,Max,Y) } {set y $TumorGrowth(Scan1,Max,Y) 
	} else { set y [expr int($y)] }
    }

    if {$z < 0 } { set z 0
    } else {
	if {$z > $TumorGrowth(Scan1,Max,Z) } {set z $TumorGrowth(Scan1,Max,Z) 
	} else { set z [expr int($z)] }
    }

    if {$TumorGrowth(ROI,MinCoord,x) == -1} {
	set TumorGrowth(ROI,MinCoord,x) $x
	set TumorGrowth(ROI,MinCoord,y) $y
	set TumorGrowth(ROI,MinCoord,z) $z
    } else {
	if {$TumorGrowth(ROI,MinCoord,x) > $x }  {set TumorGrowth(ROI,MinCoord,x) $x }
	if {$TumorGrowth(ROI,MinCoord,y) > $y }  {set TumorGrowth(ROI,MinCoord,y) $y }
	if {$TumorGrowth(ROI,MinCoord,z) > $z }  {set TumorGrowth(ROI,MinCoord,z) $z }
    }
    if {$TumorGrowth(ROI,MaxCoord,x) == -1} {
	set TumorGrowth(ROI,MaxCoord,x) $x
	set TumorGrowth(ROI,MaxCoord,y) $y
	set TumorGrowth(ROI,MaxCoord,z) $z
    } else {
	if {$TumorGrowth(ROI,MaxCoord,x) < $x }  {set TumorGrowth(ROI,MaxCoord,x) $x }
	if {$TumorGrowth(ROI,MaxCoord,y) < $y }  {set TumorGrowth(ROI,MaxCoord,y) $y }
	if {$TumorGrowth(ROI,MaxCoord,z) < $z }  {set TumorGrowth(ROI,MaxCoord,z) $z }
    }
   
    set TumorGrowth(ROI,Size,x) [expr $TumorGrowth(ROI,MaxCoord,x) - $TumorGrowth(ROI,MinCoord,x) + 1]
    set TumorGrowth(ROI,Size,y) [expr $TumorGrowth(ROI,MaxCoord,y) - $TumorGrowth(ROI,MinCoord,y) + 1]
    set TumorGrowth(ROI,Size,z) [expr $TumorGrowth(ROI,MaxCoord,z) - $TumorGrowth(ROI,MinCoord,z) + 1]
}



proc TumorGrowthScan1Select_Fct {id volDir} {
  global Volume Anno TumorGrowth

  set TumorGrowth(Scan1) $id 
  set DIM [[Volume($id,vol) GetOutput] GetDimensions]
  set TumorGrowth(Scan1,Max,X) [expr [lindex $DIM 0] -1]
  set TumorGrowth(Scan1,Max,Y) [expr [lindex $DIM 1] - 1]
  set TumorGrowth(Scan1,Max,Z) [expr [lindex $DIM 2] - 1] 

  set tmpDir ${volDir}-TG
  if {[string index $tmpDir 0 ] == "/" } {
      set TumorGrowth(save,Dir) $tmpDir
  }  else {
      set TumorGrowth(save,Dir) $::Mrml(dir)/$tmpDir
  }
}

proc TumorGrowthSuperSampleCreate_Fct { ID INPUT } {
    global TumorGrowth Volume Slice
    puts "Zoom in ROI of Scan $ID $INPUT"

    TumorGrowthROICheck
    # now cut out ROI and supersample to right size 
    catch {TumorGrowth(Scan$ID,ROI) Delete}
    vtkImageClip  TumorGrowth(Scan$ID,ROI)
        TumorGrowth(Scan$ID,ROI) SetInput $INPUT
	eval TumorGrowth(Scan${ID},ROI)  SetOutputWholeExtent $TumorGrowth(ROI,MinCoord,x) $TumorGrowth(ROI,MaxCoord,x) $TumorGrowth(ROI,MinCoord,y) $TumorGrowth(ROI,MaxCoord,y) \
	                                                      $TumorGrowth(ROI,MinCoord,z) $TumorGrowth(ROI,MaxCoord,z)
	TumorGrowth(Scan${ID},ROI) ClipDataOn   
    TumorGrowth(Scan${ID},ROI) Update 

    catch {TumorGrowth(Scan${ID},ROIExtent) Delete }
    vtkImageChangeInformation TumorGrowth(Scan${ID},ROIExtent) 
        TumorGrowth(Scan${ID},ROIExtent)  SetInput [TumorGrowth(Scan${ID},ROI) GetOutput]
        TumorGrowth(Scan${ID},ROIExtent)  SetOutputExtentStart 0 0 0 
    TumorGrowth(Scan${ID},ROIExtent) Update

    set TumorGrowth(scan${ID},save,Name) "$TumorGrowth(scan${ID},save,Name)_ROI" 

    if {$TumorGrowth(save,ROI) } { 
	TumorGrowthImageDataWriter [TumorGrowth(Scan${ID},ROIExtent) GetOutput] $TumorGrowth(scan${ID},save,Name)
	TumorGrowthTextWriter $TumorGrowth(scan${ID},save,Name) "ROI: $TumorGrowth(ROI,MinCoord,x) $TumorGrowth(ROI,MaxCoord,x) $TumorGrowth(ROI,MinCoord,y) $TumorGrowth(ROI,MaxCoord,y) $TumorGrowth(ROI,MinCoord,z) $TumorGrowth(ROI,MaxCoord,z)" 
    }

    # Determine Coeficients for resampling 
    set Spacing  [[Volume($TumorGrowth(Scan1),vol) GetOutput] GetSpacing] 	    

    if {$ID == 1} {
	set Spacing0 [lindex $Spacing 0]
	set TempSpacing [expr $TumorGrowth(ROI,Size,x) * $Spacing0 / 100.0]
	if {$TempSpacing < 0.3 } { set NewSpacing 0.3 
	} else {set NewSpacing  $TempSpacing }
	
	set Spacing1 [lindex $Spacing 1]
	set TempSpacing [expr $TumorGrowth(ROI,Size,y) * $Spacing1 / 100.0]
	if {$TempSpacing > $NewSpacing } { set NewSpacing  $TempSpacing }
	
	set Spacing2 [lindex $Spacing 2]
	set TempSpacing [expr $TumorGrowth(ROI,Size,z) * $Spacing2 / 100.0]
	if {$TempSpacing > $NewSpacing } { set NewSpacing  $TempSpacing }
	
	set TumorGrowth(ROI,SuperSampleSpacing) $NewSpacing
	set TumorGrowth(ROI,SuperSampleVoxelVolume) [expr $NewSpacing*$NewSpacing*$NewSpacing ]
	set TumorGrowth(ROI,RatioNewOldSpacing) [expr $TumorGrowth(ROI,SuperSampleVoxelVolume)/($Spacing0*$Spacing1*$Spacing2) ]
    }

    catch {TumorGrowth(Scan${ID},ROISuperSample) Delete}
    vtkImageResample TumorGrowth(Scan${ID},ROISuperSample)
       TumorGrowth(Scan${ID},ROISuperSample) SetDimensionality 3
       TumorGrowth(Scan${ID},ROISuperSample) SetInterpolationModeToLinear
       TumorGrowth(Scan${ID},ROISuperSample) SetInput [TumorGrowth(Scan${ID},ROIExtent) GetOutput]
       TumorGrowth(Scan${ID},ROISuperSample) SetAxisOutputSpacing 0 $TumorGrowth(ROI,SuperSampleSpacing)
       TumorGrowth(Scan${ID},ROISuperSample) SetAxisOutputSpacing 1 $TumorGrowth(ROI,SuperSampleSpacing)
       TumorGrowth(Scan${ID},ROISuperSample) SetAxisOutputSpacing 2 $TumorGrowth(ROI,SuperSampleSpacing)
       TumorGrowth(Scan${ID},ROISuperSample) ReleaseDataFlagOff
    TumorGrowth(Scan${ID},ROISuperSample) Update

    set TumorGrowth(scan${ID},save,Name) "$TumorGrowth(scan${ID},save,Name)_SuperSample" 
}



proc TumorGrowthPreSegmentCreate_Fct { INPUT } {
    global TumorGrowth 
    catch {TumorGrowth(Scan1,PreSegment) Delete}
    vtkImageThreshold TumorGrowth(Scan1,PreSegment)
	  TumorGrowth(Scan1,PreSegment) SetInput $INPUT  
	  TumorGrowth(Scan1,PreSegment) SetInValue 10
	  TumorGrowth(Scan1,PreSegment) SetOutValue 0
	  TumorGrowth(Scan1,PreSegment) ThresholdByUpper $TumorGrowth(Scan1,Threshold)  
 	  TumorGrowth(Scan1,PreSegment) SetOutputScalarTypeToShort
    TumorGrowth(Scan1,PreSegment) Update
}

proc TumorGrowthSegment_Fct { } {
    global TumorGrowth
    vtkImageIslandFilter TumorGrowth(Scan1,Segment)
    TumorGrowth(Scan1,Segment) SetIslandMinSize $TumorGrowth(Step4,IslandMinSize)
    TumorGrowth(Scan1,Segment) SetInput [TumorGrowth(Scan1,PreSegment) GetOutput]
    TumorGrowth(Scan1,Segment) SetNeighborhoodDim3D
    TumorGrowth(Scan1,Segment) Update 
}

proc TumorGrowthHistogramNormalization_Fct { } {
    global TumorGrowth 

    puts "Match intensities of Scan2 to Scan1 with Type: $TumorGrowth(Step5,HistogramType)" 
    catch {HistTemp Delete}

    if { $TumorGrowth(Step5,HistogramType) == "ITK" } {
      vtkImageAccumulate HistTemp
         HistTemp SetInput [TumorGrowth(Scan1,ROISuperSample) GetOutput]
      HistTemp Update
      set Min [lindex [HistTemp GetMin] 0]
      set Max [lindex [HistTemp GetMax] 0]
      set bins [expr $Max - $Min + 1]
      HistTemp Delete
      
      catch {TumorGrowth(Scan2,ROISuperSampleNormalized) Delete}
      vtkITKHistogramMatchingImageFilter TumorGrowth(Scan2,ROISuperSampleNormalized)
         TumorGrowth(Scan2,ROISuperSampleNormalized) SetSourceImage    [TumorGrowth(Scan2,ROISuperSample) GetOutput] 
         TumorGrowth(Scan2,ROISuperSampleNormalized) SetReferenceImage [TumorGrowth(Scan1,ROISuperSample) GetOutput] 
         TumorGrowth(Scan2,ROISuperSampleNormalized) SetThresholdAtMeanIntensity 0
         TumorGrowth(Scan2,ROISuperSampleNormalized) SetNumberOfHistogramLevels $bins
         TumorGrowth(Scan2,ROISuperSampleNormalized) SetNumberOfMatchPoints $bins
      TumorGrowth(Scan2,ROISuperSampleNormalized) Update
    } else {
      # Just norm the mean values inside the tumor 

	# Just use pixels that are clearly inside the tumor => generate label map of inside tumor 
	set INPUT [TumorGrowth(Scan1,PreSegment) GetOutput]
	catch {TUMOR_DIST Delete}
	vtkImageKilianDistanceTransform TUMOR_DIST 
	  TUMOR_DIST   SetInput $INPUT
          TUMOR_DIST   SetAlgorithmToSaito
          TUMOR_DIST   SignedDistanceMapOn
          TUMOR_DIST   SetObjectValue  10 
          TUMOR_DIST   SetZeroBoundaryInside
          TUMOR_DIST   DistanceTransform
          TUMOR_DIST   SetMaximumDistance 100 
          TUMOR_DIST   ConsiderAnisotropyOff
        TUMOR_DIST   Update

	vtkImageAccumulate HistTemp
           HistTemp SetInput [TUMOR_DIST  GetOutput]
        HistTemp Update
        
        set Max [lindex [HistTemp GetMax] 0]
        HistTemp Delete
	
	catch {TUMOR_INSIDE Delete}
	vtkImageThreshold TUMOR_INSIDE
	  TUMOR_INSIDE SetOutputScalarType [$INPUT GetScalarType] 
	  TUMOR_INSIDE SetInput [TUMOR_DIST GetOutput]
	  TUMOR_INSIDE ThresholdByUpper [expr $Max*0.5]
          TUMOR_INSIDE SetInValue 1
          TUMOR_INSIDE SetOutValue 0
        TUMOR_INSIDE Update

        # Calculate the mean for scan 1 and Scan 2 (we leave out the factor of voxels bc it does not matter latter 
	foreach ID "1 2" {
	   vtkImageMathematics HighIntensityRegion
	      HighIntensityRegion SetInput1 [TUMOR_INSIDE GetOutput] 
	      if {[catch {set INPUT [TumorGrowth(Scan${ID},ROISuperSample) GetOutput] }] } {
		  set INPUT [Volume($TumorGrowth(Scan${ID},ROISuperSample,id),vol) GetOutput] 
	      } 
  
	      HighIntensityRegion SetInput2  $INPUT
	      HighIntensityRegion SetOperationToMultiply
	   HighIntensityRegion Update 
	   
           vtkImageSumOverVoxels SUM
	        SUM SetInput [HighIntensityRegion GetOutput] 
	    SUM Update

	    set TumorGrowth(Scan${ID},ROI_SUM_INTENS) [SUM GetVoxelSum ]
	    SUM Delete
	    HighIntensityRegion Delete
	} 
        TUMOR_DIST Delete
        TUMOR_INSIDE Delete
 
        # Multiply scan2 with the factor that normalizes both mean  
	set NormFactor [expr  double($TumorGrowth(Scan1,ROI_SUM_INTENS)) / double($TumorGrowth(Scan2,ROI_SUM_INTENS))]  
	puts "Intensity Normalization Factor:  $NormFactor"

	if {[catch {set INPUT [TumorGrowth(Scan2,ROISuperSample) GetOutput] }] } {
	    set INPUT [Volume($TumorGrowth(Scan2,ROISuperSample,id),vol) GetOutput] 
	} 

	vtkImageMathematics TumorGrowth(Scan2,ROISuperSampleNormalized)
            TumorGrowth(Scan2,ROISuperSampleNormalized) SetInput1  $INPUT 
            TumorGrowth(Scan2,ROISuperSampleNormalized) SetOperationToMultiplyByK 
 	    TumorGrowth(Scan2,ROISuperSampleNormalized) SetConstantK $NormFactor
	TumorGrowth(Scan2,ROISuperSampleNormalized) Update
    }

    # Save outcome  
    set TumorGrowth(scan2,save,Name) "$TumorGrowth(scan2,save,Name)_NORM" 
    set TumorGrowth(scan2,save,NormName) "$TumorGrowth(scan2,save,Name)"
}

proc TumorGrowthIntensityThresholding_Fct { ID } {
    # Eveyrthing outside below threhold is set to threshold
    global TumorGrowth Volume

    catch {TumorGrowth(Scan${ID},ROIThreshold) Delete}
    vtkImageThreshold TumorGrowth(Scan${ID},ROIThreshold)
        TumorGrowth(Scan${ID},ROIThreshold) ThresholdByUpper $TumorGrowth(Scan1,Threshold)  
        if {$ID == 1 } {
	    if {[catch {set INPUT [TumorGrowth(Scan1,ROISuperSample) GetOutput] }] } {
		set INPUT [Volume($TumorGrowth(Scan1,ROISuperSample,id),vol) GetOutput] 
	    } 
	    TumorGrowth(Scan${ID},ROIThreshold) SetInput  $INPUT
        } else {
	    # Is changed bc we modified order of stepts - now we use locally registered one instead of normalized images 
	    if {[catch {TumorGrowth(Scan${ID},ROIThreshold) SetInput  TumorGrowth(Scan2ToScan1,Local,vol) } ] } {
		TumorGrowth(Scan${ID},ROIThreshold) SetInput [Volume($TumorGrowth(Scan2ToScan1,Local,id),vol) GetOutput] 
	    } 
	}
    
        TumorGrowth(Scan${ID},ROIThreshold) ReplaceInOff  
        TumorGrowth(Scan${ID},ROIThreshold) SetOutValue $TumorGrowth(Scan1,Threshold)  
        TumorGrowth(Scan${ID},ROIThreshold) SetOutputScalarTypeToShort
    TumorGrowth(Scan${ID},ROIThreshold) Update

    set TumorGrowth(scan${ID},save,Name) "$TumorGrowth(scan${ID},save,Name)_THR" 
}

# Gaussian functions 
# The inverse of the erf (or Error Function http://en.wikipedia.org/wiki/Error_function ) 
# This is an approximation of the error function to the 20th order  - see http://functions.wolfram.com/GammaBetaErf/InverseErf/06/01/0001/

# InverseErf[z] == (Sqrt[Pi]/2) (z + (Pi z^3)/12 + (7 Pi^2 z^5)/480 + (127 Pi^3 z^7)/40320 + (4369 Pi^4 z^9)/5806080 + (34807 Pi^5 z^11)/182476800 + (20036983 Pi^6 z^13)/398529331200 + (2280356863 Pi^7 z^15)/167382319104000 + (49020204823 Pi^8 z^17)/ 13007997370368000 + (65967241200001 Pi^9 z^19)/62282291409321984000) + O[z^20]

proc  TumorGrowthAnalysis_InverseErf { z } {

   # Values are computed via matlab
   # sqrt(pi)/2
   set tcl_precision_old  $::tcl_precision
   set ::tcl_precision 17
   set Norm  0.88622692545276

   # 1
   set c(1) 1.0

   # pi/12
   set c(3)  0.26179938779915

   # 7*pi^2 /480
   set c(5)  0.14393173084922

   # 127* pi^3 /40320 
   set c(7)  0.09766361950392

   # 4369/5806080 * pi^4 
   set c(9) 0.07329907936638

   # 34807 /182476800 * pi^5 
   set c(11) 0.05837250087858

   # 20036983 /398529331200 *pi^6
   set c(13) 0.04833606317018

   # 2280356863 /167382319104000 * pi^7
   set c(15) 0.04114739494052

   # 49020204823/ 13007997370368000 * pi^8 
   set c(17) 0.03575721309236

   # 65967241200001/62282291409321984000 * pi^9 
   set c(19) 0.0315727633198

   set result 0.0 
   set sqr_z [expr $z*$z]

   for {set i 1} {$i < 20 } {incr i 2} {
       set result [expr $result + $c($i)*$z]
       set z [expr $z*$sqr_z]
   }  

   set result  [expr $result*$Norm]
   set ::tcl_precision $tcl_precision_old  
   return $result

}

# The result is n so that prob = N(x <= n ; \mu ,\sigma^2) 
proc TumorGrowthAnalysis_InverseStandardCumulativeDistribution { prob mu sigma } {
    if {($prob < 0) ||  $prob > 1} {return [expr sqrt(-1)]}

    set InvErf [TumorGrowthAnalysis_InverseErf [expr 2*$prob -1 ]]
    return [expr $mu + $sigma *sqrt(2)* $InvErf]
}

# Compute threshold based on Gaussian noise in segmented region 
proc TumorGrowthAnalysis_ComputeThreshold {Scan1SubScan2 Scan1Segment } {
    global TumorGrowth
    # compute Gaussian pdf for noise
    vtkImageMathematics compThrNoise 
       compThrNoise  SetInput1 $Scan1SubScan2
       compThrNoise  SetOperationToAbsoluteValue
    compThrNoise  Update

    # Make sure that Segmentation is binarized 
    vtkImageThreshold compThrROI 
	 compThrROI SetInput $Scan1Segment 
	 compThrROI SetInValue 1
	 compThrROI SetOutValue 0
	 compThrROI  ThresholdByUpper 1 
 	 compThrROI  SetOutputScalarTypeToShort
    compThrROI  Update

    # -----------------------------------------------------
    # Compute Mean     
    vtkImageMathematics compThrROINoise 
       compThrROINoise  SetInput1 [compThrROI  GetOutput]
       compThrROINoise  SetInput2 [compThrNoise  GetOutput]
       compThrROINoise  SetOperationToMultiply 
    compThrROINoise  Update

    # Compute Nominator 
    vtkImageSumOverVoxels compThrSum
       compThrSum SetInput [compThrROINoise GetOutput]
    compThrSum Update
    set IntensityDiffTotal   [compThrSum GetVoxelSum]

    # Compute Denominator 
    compThrSum SetInput [compThrROI GetOutput]
    compThrSum Update
    set SizeOfROI [compThrSum GetVoxelSum]

    set MeanNoise [expr  double($IntensityDiffTotal) / double($SizeOfROI)]

    # -----------------------------------------------------
    # Compute Variance

    # Subtract mean
    vtkImageMathematics compThrROINoiseSubMean 
       compThrROINoiseSubMean  SetInput1 [compThrROINoise  GetOutput]
       compThrROINoiseSubMean  SetOperationToAddConstant 
       compThrROINoiseSubMean  SetConstantC -$MeanNoise
    compThrROINoiseSubMean  Update

    # Only consider region of interest
    vtkImageMathematics compThrVarianceInput 
       compThrVarianceInput   SetInput1 [compThrROI  GetOutput]
       compThrVarianceInput   SetInput2 [compThrROINoiseSubMean  GetOutput]
       compThrVarianceInput  SetOperationToMultiply 
    compThrVarianceInput  Update
 
    # Now square the input 
    vtkImageMathematics compThrVarianceInputSqr 
       compThrVarianceInputSqr   SetInput1 [compThrVarianceInput  GetOutput]
       compThrVarianceInputSqr  SetOperationToSquare 
    compThrVarianceInputSqr  Update
 
    # Define Variance 
    compThrSum SetInput [compThrVarianceInputSqr GetOutput]
    compThrSum Update
    set Nominator [compThrSum GetVoxelSum]

    set Variance [expr  double($Nominator) / (double($SizeOfROI) - 1.0)]

    # ----------------------------------------
    # Clean Up
    compThrVarianceInputSqr Delete
    compThrVarianceInput Delete
    compThrROINoiseSubMean Delete 
    compThrSum      Delete
    compThrROINoise Delete
    compThrROI      Delete
    compThrNoise    Delete

    # ----------------------------------------
    # Compute Threshold
    # the threshold value that excludes 
    set ThresholdValue [TumorGrowthAnalysis_InverseStandardCumulativeDistribution $TumorGrowth(AnalysisSensitivityValue)  $MeanNoise [expr sqrt($Variance)]]
    if { $ThresholdValue < 0.0 } { set ThresholdValue 0.0 }
    puts "ComputeThreshold -- Mean: $MeanNoise Variance: $Variance Threshold: $ThresholdValue"
    
    return $ThresholdValue
}


proc TumorGrowthAnalysis_Fct {Scan1Data Scan1Segment Scan2Data } {
    global TumorGrowth
    puts "Start Tumor Growth Analysis" 
    # Subtract consecutive scans from each other
    catch {TumorGrowth(FinalSubtract)  Delete } 
    vtkImageMathematics TumorGrowth(FinalSubtract)
       TumorGrowth(FinalSubtract) SetInput1 $Scan2Data 
       TumorGrowth(FinalSubtract) SetInput2 $Scan1Data 
       TumorGrowth(FinalSubtract) SetOperationToSubtract  
    TumorGrowth(FinalSubtract) Update
    # do a little bit of smoothing 

    vtkImageMedian3D TumorGrowth(FinalSubtractSmooth)
       TumorGrowth(FinalSubtractSmooth) SetInput [TumorGrowth(FinalSubtract) GetOutput]
       TumorGrowth(FinalSubtractSmooth) SetKernelSize 3 3 3
       TumorGrowth(FinalSubtractSmooth) ReleaseDataFlagOff
    TumorGrowth(FinalSubtractSmooth) Update

    set TumorGrowth(FinalAnalysisThreshold) [TumorGrowthAnalysis_ComputeThreshold [TumorGrowth(FinalSubtractSmooth) GetOutput] $Scan1Segment ]

    # Change label 
    catch {TumorGrowth(FinalROI) Delete } 
    vtkImageThreshold TumorGrowth(FinalROI) 
	  TumorGrowth(FinalROI)  SetInput $Scan1Segment 
	  TumorGrowth(FinalROI)  SetInValue 1
	  TumorGrowth(FinalROI)  SetOutValue 0
	  TumorGrowth(FinalROI)  ThresholdByLower 0 
 	  TumorGrowth(FinalROI)  SetOutputScalarTypeToShort
    TumorGrowth(FinalROI) Update

    catch {TumorGrowth(FinalMultiply)  Delete } 
    vtkImageMathematics TumorGrowth(FinalMultiply)
       TumorGrowth(FinalMultiply) SetInput1 [TumorGrowth(FinalROI)       GetOutput] 
       TumorGrowth(FinalMultiply) SetInput2 [TumorGrowth(FinalSubtractSmooth)  GetOutput] 
       TumorGrowth(FinalMultiply) SetOperationToMultiply  
    TumorGrowth(FinalMultiply) Update

    catch {TumorGrowth(FinalAnalysis) Delete } 
    vtkImageThreshold TumorGrowth(FinalAnalysis) 
	  TumorGrowth(FinalAnalysis) SetInput [TumorGrowth(FinalMultiply) GetOutput] 
	  TumorGrowth(FinalAnalysis) ReplaceInOff
	  TumorGrowth(FinalAnalysis) SetOutValue 0
	  TumorGrowth(FinalAnalysis) ThresholdByUpper  $TumorGrowth(FinalAnalysisThreshold)
 	  TumorGrowth(FinalAnalysis) SetOutputScalarTypeToShort
    TumorGrowth(FinalAnalysis) Update

    catch {TumorGrowth(FinalROINegativeBin)  Delete } 
    vtkImageThreshold TumorGrowth(FinalROINegativeBin) 
	  TumorGrowth(FinalROINegativeBin) SetInput [TumorGrowth(FinalMultiply) GetOutput] 
	  TumorGrowth(FinalROINegativeBin) SetInValue -1
	  TumorGrowth(FinalROINegativeBin) SetOutValue 0
	  TumorGrowth(FinalROINegativeBin) ThresholdByLower  -$TumorGrowth(FinalAnalysisThreshold)
 	  TumorGrowth(FinalROINegativeBin) SetOutputScalarTypeToShort
    TumorGrowth(FinalROINegativeBin) Update

    # Initializing tumor growth prediction
    vtkImageThreshold TumorGrowth(FinalROIBin) 
	  TumorGrowth(FinalROIBin)  SetInput [TumorGrowth(FinalAnalysis) GetOutput] 
	  TumorGrowth(FinalROIBin)  SetInValue 1
	  TumorGrowth(FinalROIBin)  SetOutValue 0
	  TumorGrowth(FinalROIBin)  ThresholdByUpper 1 
 	  TumorGrowth(FinalROIBin)  SetOutputScalarTypeToShort
    TumorGrowth(FinalROIBin) Update

    vtkImageMathematics TumorGrowth(FinalROIBinReal) 
	  TumorGrowth(FinalROIBinReal)  SetInput 0 [TumorGrowth(FinalROIBin) GetOutput] 
	  TumorGrowth(FinalROIBinReal)  SetInput 1 [TumorGrowth(FinalROINegativeBin) GetOutput] 
	  TumorGrowth(FinalROIBinReal)  SetOperationToAdd 
    TumorGrowth(FinalROIBinReal) Update

    # Remove small islands - slowes it down a lot 
    #vtkImageIslandFilter TumorGrowth(FinalROIBinRealIsl) 
    #  TumorGrowth(FinalROIBinRealIsl)  SetIslandMinSize 2 
    #  TumorGrowth(FinalROIBinRealIsl) SetInput [TumorGrowth(FinalROIBinReal) GetOutput]
    #  TumorGrowth(FinalROIBinRealIsl) SetNeighborhoodDim3D 
    #  TumorGrowth(FinalROIBinRealIsl) SetIslandOutputLabel 0
    #  TumorGrowth(FinalROIBinRealIsl) SetPrintInformation 0
    # TumorGrowth(FinalROIBinRealIsl) Update

   
    vtkImageSumOverVoxels TumorGrowth(FinalROITotal) 
    TumorGrowth(FinalROITotal)  SetInput [TumorGrowth(FinalROIBinReal) GetOutput]
    return $TumorGrowth(FinalAnalysisThreshold)
}

proc TumorGrowthMeassuringGrowth_Fct { } {
    global TumorGrowth

    # Not yet that far in the step structure    
    if { [catch {TumorGrowth(FinalAnalysis) ThresholdByUpper  $TumorGrowth(FinalAnalysisThreshold)}] } { return ""}
    TumorGrowth(FinalAnalysis) Update

    TumorGrowth(FinalROINegativeBin) ThresholdByLower  -$TumorGrowth(FinalAnalysisThreshold)
    TumorGrowth(FinalROINegativeBin) Update
   
    TumorGrowth(FinalROITotal)  Update
    
    set SUM [TumorGrowth(FinalROITotal) GetVoxelSum ]
    # if {$SUM < 0} { set SUM 0}
    
    return "[format %.3f [expr $SUM*$TumorGrowth(ROI,SuperSampleVoxelVolume)]] mm^3 ([expr int($SUM*$TumorGrowth(ROI,RatioNewOldSpacing))] Voxels)"
}



####
# Misc 

# This copy function is specific to AG how we use it - so inverse - input - inverseflag are nor copied 
proc TumorGrowthCopy_vtkGeneralTransform {Input Output} {
    global TumorGrowth
    
    # This is just important so that the transformed are stored in the same order 
    $Output PostMultiply 
    set num [$Input GetNumberOfConcatenatedTransforms]  
    # Should always be just 1 
    for {set i 0 } {$i < $num } { incr i } {
	set TRANSFORM [$Input GetConcatenatedTransform $i]
	if {[$TRANSFORM IsA vtkTransform]} {
	    incr TumorGrowth(TransformIndex) 
	    set index $TumorGrowth(TransformIndex) 
	    vtkTransform TumorGrowth(Transform,$index)
	    TumorGrowthCopy_vtkTranform $TRANSFORM TumorGrowth(Transform,$index)
	    $Output Concatenate TumorGrowth(Transform,$index)
	} else {
	    DevErrorWindow "Copying Transform Failed - update TumorGrowthCopy_vtkGeneralTransform"
	}
    }
}

proc TumorGrowthIntensityThresholdingDelete { ID } {
    global TumorGrowth Volume
    if {$TumorGrowth(Scan${ID},ROIThreshold,id) != $Volume(idNone) } {
	MainMrmlDeleteNode Volume $TumorGrowth(Scan${ID},ROIThreshold,id)
	RenderAll
	set  TumorGrowth(Scan2,ROISuperSampleNormalized,id) $Volume(idNone)
	catch {TumorGrowth(Scan${ID},ROIThreshold) Delete}
    }
}

proc TumorGrowthHistogramNormalizationDelete { } {
    global TumorGrowth Volume
    if {$TumorGrowth(Scan2,ROISuperSampleNormalized,id) != $Volume(idNone) } {
	MainMrmlDeleteNode Volume $TumorGrowth(Scan2,ROISuperSampleNormalized,id)
	RenderAll
	set  TumorGrowth(Scan2,ROISuperSampleNormalized,id) $Volume(idNone)
	catch {TumorGrowth(Scan2,ROISuperSampleNormalized) Delete}
    }
}

proc TumorGrowthSuperSampleDelete { ID } {
    global TumorGrowth Volume
    if {$TumorGrowth(Scan${ID},ROISuperSample,id) != $Volume(idNone) } {
	MainMrmlDeleteNode Volume $TumorGrowth(Scan${ID},ROISuperSample,id)
	catch {TumorGrowth(Scan${ID},ROI) Delete}
	catch {TumorGrowth(Scan${ID},ROIExtent) Delete}
	catch {TumorGrowth(Scan${ID},ROISuperSample) Delete }
	RenderAll
	set TumorGrowth(Scan${ID},ROISuperSample,id) $Volume(idNone)
    }
}


proc TumorGrowthCopy_vtkTranform {Input Output} {
    $Output PostMultiply 
    $Output SetMatrix [$Input GetMatrix] 
    $Output GetInverse
}

proc TumorGrowthDelete_vtkGeneralTransform { INPUT } {
    set num [$Input GetNumberOfConcatenatedTransforms]  
    # Should always be just 1 
    for {set i 0 } {$i < $num } { incr i } {
	[$Input GetConcatenatedTransform $i] Delete
    }
}


proc TumorGrowthSegmentDelete { } {
    global TumorGrowth Volume
    if {$TumorGrowth(Scan1,Segment,id) != $Volume(idNone) } {
	MainMrmlDeleteNode Volume $TumorGrowth(Scan1,Segment,id)
	RenderAll
	set TumorGrowth(Scan1,Segment,id) $Volume(idNone)
	catch {TumorGrowth(Scan1,Segment) Delete}
    }
}

proc TumorGrowthRegistrationDelete { } {
    global TumorGrowth Volume
    if { $TumorGrowth(Scan2ToScan1,Global,id) != $Volume(idNone) }  {
        MainMrmlDeleteNode Volume $TumorGrowth(Scan2ToScan1,Global,id)
	set TumorGrowth(Scan2ToScan1,Global,id) $Volume(idNone)
    } 
    if { $TumorGrowth(Scan2ToScan1,Local,id) != $Volume(idNone) }  {
        MainMrmlDeleteNode Volume $TumorGrowth(Scan2ToScan1,Local,id)
	set TumorGrowth(Scan2ToScan1,Local,id) $Volume(idNone)
	MainMrmlDeleteNode Volume $TumorGrowth(Scan2ToScan1,LocalNormal,id)
	set TumorGrowth(Scan2ToScan1,LocalNormal,id) $Volume(idNone)
    } 
    puts "=========== BUG: delete transform if Scan1 or Scan2 is changed"
}


proc  TumorGrowthPreSegmentDelete { } {
    global TumorGrowth Volume
    if {$TumorGrowth(Scan1,PreSegment,id) != $Volume(idNone) } {
	MainMrmlDeleteNode Volume $TumorGrowth(Scan1,PreSegment,id)
	RenderAll
	set TumorGrowth(Scan1,PreSegment,id) $Volume(idNone)
	catch {TumorGrowth(Scan1,PreSegment) Delete}
    }
}

proc TumorGrowthAnalysisDelete { } {
    global TumorGrowth Volume
    if {$TumorGrowth(FinalAnalysis,id) != $Volume(idNone) } {
	MainMrmlDeleteNode Volume $TumorGrowth(FinalAnalysisFull,id)
	MainMrmlDeleteNode Volume $TumorGrowth(FinalAnalysis,id)
	RenderAll
	set TumorGrowth(FinalAnalysis,id) $Volume(idNone)
	catch {TumorGrowth(FinalAnalysis) Delete } 
        catch {TumorGrowth(FinalMultiply)  Delete } 
	catch {TumorGrowth(FinalSubtract)  Delete }
	catch {TumorGrowth(FinalSubtractSmooth)  Delete }
	catch {TumorGrowth(FinalROI) Delete } 
	catch {TumorGrowth(FinalROIBin) Delete } 
	catch {TumorGrowth(FinalROITotal) Delete } 
	catch {TumorGrowth(FinalROIBinReal) Delete } 
        catch {TumorGrowth(FinalROINegativeBin) Delete}
    }
}
