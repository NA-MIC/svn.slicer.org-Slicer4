#!/bin/sh
# the next line restarts using tclsh \
    exec wish "$0" "$@"

wm withdraw .

#
# launch.tcl
#
# This script is used to set platform-specific variables for the shell
# that will be used to launch slicer.
#
# - what platform you're on so correct libs are loaded
# - what modules are present so they can be loaded
# - set all PATH, LD_LIBRARY_PATH, TCLLIBPATH, and other shell-level
#   variables to reflect that state
#   
# This is a tcl script rather than a .bat or .sh file so it can handle all 
# the details in one place for all platforms.
#
# This script is used for both the slicer build directory and for the slicer
# install directory.
 

# these are the directories needed for the cpacked install directory:
#/tmp/Slicer3-3.0.2007-02-06-Linux/lib
#/tmp/Slicer3-3.0.2007-02-06-Linux/lib/KWWidgets:
#/tmp/Slicer3-3.0.2007-02-06-Linux/lib/InsightToolkit
#/tmp/Slicer3-3.0.2007-02-06-Linux/lib/Slicer3/tcl/lib

set ::BUILD_SUBDIR  ""
if { [string match -nocase "windows*" $::tcl_platform(os)] } {
  set ::BUILD_SUBDIR  @CMAKE_BUILD_TYPE@
}

set ::env(VTK_DIR)           [file normalize @VTK_DIR@]
set ::env(VTK_BIN_DIR)       [file normalize @VTK_DIR@/bin/$::BUILD_SUBDIR]
set ::env(KWWidgets_DIR)     [file normalize @KWWidgets_DIR@]
set ::env(KWWidgets_BIN_DIR) [file normalize @KWWidgets_DIR@/bin/$::BUILD_SUBDIR]
set ::env(ITK_BIN_DIR)       [file normalize @ITK_DIR@/bin/$::BUILD_SUBDIR]
set ::env(SANDBOX_BIN_DIR)   ""
set ::env(TCL_LIBRARY)       [file normalize @TCL_LIBRARY@]
set ::env(TCL_DIR)           [file normalize [file dirname [file dirname $::env(TCL_LIBRARY)]]]
set ::env(TEEM_DIR)          [file normalize @TEEM_DIR@/bin/$::BUILD_SUBDIR]
set ::env(SLICER_BIN_DIR)    [file normalize @LIBRARY_OUTPUT_PATH@/$::BUILD_SUBDIR]

#
# set up variables for the OS Builds
# 
set ::SOLARIS "solaris8"
set ::LINUX "linux-x86"
set ::LINUX_64 "linux-x86_64"
set ::DARWIN "darwin-ppc"
set ::DARWIN_X86 "darwin-x86"
set ::WINDOWS "win32"

#
# set the default locations for the main components
#
switch $::tcl_platform(os) {
    "SunOS" { set ::env(BUILD) $::SOLARIS }
    "Linux" {           
        if {$::tcl_platform(machine) == "x86_64"} {
            set ::env(BUILD) $::LINUX_64 
        } else {
            set ::env(BUILD) $::LINUX
        }
    }       
    "Darwin" { 
        if {$::tcl_platform(machine) == "i386"} {
            set ::env(BUILD) $::DARWIN_X86
        } else {
            set ::env(BUILD) $::DARWIN 
        }
    }
    default { 
        set ::env(BUILD) $::WINDOWS 
    }
}
proc launch_InitEnvironment {} {

    # if SLICER_HOME not set, find it relative to the location of this script
    # -- when run by the launcher, this variable will be set
    if { ![info exists ::SLICER_HOME] } {
        set wd [pwd]
        cd [file dirname [file dirname [info script]]]
        set ::SLICER_HOME [pwd]
        cd $wd
    }
    set ::env(SLICER_HOME) $::SLICER_HOME

    if { $::env(BUILD) == $::WINDOWS } {
        set ::SLICER_HOME [file attributes $::SLICER_HOME -shortname]
        set ::env(SLICER_HOME) $::SLICER_HOME
    }

    # if it is an empty string or doesn't exist, set the LD_LIBRARY_PATH 
    if { ![info exists ::env(LD_LIBRARY_PATH)] ||
            $::env(LD_LIBRARY_PATH) == "" } {
        set ::env(LD_LIBRARY_PATH) " "
    }

    # if it is an empty string or doesn't exist, set the TCLLIBPATH 
    if {[catch {
        if {$::env(TCLLIBPATH) == ""} { 
            set ::env(TCLLIBPATH) " " 
        }} ex]} {
        set ::env(TCLLIBPATH) " " 
    }

    # if it is an empty string or doesn't exist, set the DYLD_LIBRARY_PATH 
    if { ($::env(BUILD) == $::DARWIN || $::env(BUILD) == $::DARWIN_X86) && [catch {
        if {$::env(DYLD_LIBRARY_PATH) == ""} { 
            set ::env(DYLD_LIBRARY_PATH) " " 
        }} ex]} {
        set ::env(DYLD_LIBRARY_PATH) " "
    }
}


proc launch_SetPaths {} {
    #
    # add the necessary library directories, both Base and Modules, to the 
    # LD_LIBRARY_PATH environment variable
    #
    #
    # set the base library paths for this build 
    # 
    if {$::env(BUILD) == $::SOLARIS ||
        $::env(BUILD) == $::LINUX_64 || 
        $::env(BUILD) == $::LINUX} {
        # add vtk, slicer, and tcl bins
            set ::env(LD_LIBRARY_PATH) $::env(VTK_BIN_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(KWWidgets_BIN_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(ITK_BIN_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(TCL_DIR)/lib:$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(TEEM_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(SLICER_BIN_DIR):$::env(LD_LIBRARY_PATH)
        } elseif {$::env(BUILD) ==  $::DARWIN || $::env(BUILD) == $::DARWIN_X86} { 
            # add vtk, slicer, and tcl bins
            set ::env(DYLD_LIBRARY_PATH) $::env(VTK_BIN_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(KWWidgets_BIN_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(ITK_BIN_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(TCL_DIR)/lib:$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(TEEM_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(SLICER_BIN_DIR):$::env(DYLD_LIBRARY_PATH)
        } elseif {$::env(BUILD) == $::WINDOWS} {
            # add vtk, slicer, and tcl bins
            set ::env(Path) $::env(VTK_BIN_DIR)\;$::env(Path)
            set ::env(Path) $::env(KWWidgets_BIN_DIR)\;$::env(Path)
            set ::env(Path) $::env(ITK_BIN_DIR)\;$::env(Path)
            set ::env(Path) $::env(TCL_DIR)/bin\;$::env(Path)
            set ::env(Path) $::env(TEEM_DIR)\;$::env(Path)
            set ::env(Path) $::env(SLICER_BIN_DIR)\;$::env(Path)
        } else {
            puts stderr "Libraries: unknown build $::env(BUILD)"
        }

    # set the base tcl/tk library paths, using the previously defined TCL_LIB_DIR
    set ::env(TCL_LIBRARY) $::env(TCL_DIR)/lib/tcl8.4
    set ::env(TK_LIBRARY) $::env(TCL_DIR)/lib/tk8.4

    #
    # add the default search locations for tcl packages
    #  (window has special tcl packages depending on build type)
    #
    if {$::env(BUILD) == $::SOLARIS || 
        $::env(BUILD) == $::LINUX ||
        $::env(BUILD) == $::LINUX_64 ||
        $::env(BUILD) == $::DARWIN_X86 ||
        $::env(BUILD) == $::DARWIN} {
            set ::env(TCLLIBPATH) "$::env(VTK_DIR)/Wrapping/Tcl $::env(TCLLIBPATH)"
            set ::env(TCLLIBPATH) "$::env(KWWidgets_DIR)/Wrapping/Tcl $::env(TCLLIBPATH)"
    } elseif {$::env(BUILD) == $::WINDOWS} {
        set ::env(TCLLIBPATH) "$::env(VTK_DIR)/Wrapping/Tcl/$::BUILD_SUBDIR $::env(TCLLIBPATH)"
        set ::env(TCLLIBPATH) "$::env(KWWidgets_DIR)/Wrapping/Tcl/$::BUILD_SUBDIR $::env(TCLLIBPATH)"
    } else {
        puts stderr "TCLLIBPATH: Invalid build $::env(BUILD)"
        exit
    }

    # same for all platforms
    set ::env(TCLLIBPATH) "$::env(SLICER_HOME)/Base/Wrapping/Tcl/vtkSlicerBase $::env(TCLLIBPATH)"
}

#
# optional - show splash screen
#
proc launch_SplashScreen {} {

  toplevel .splash
  label .splash.l -text "Placeholder Splash Screen.\n\nSlicer3 starting..."
  pack .splash.l
  update
  after 1000 "destroy .splash"

}

#
# optional - show dialog
#
proc launch_LicenseDialog {} {


    set msg "Slicer is an experimental software package.\nAny clinical use requires proper research controls.\nSelecting \"Ok\" below binds you to the license agreement.\nSee www.slicer.org for details.\n"

    set argv0 [lindex $::argv 0]
    if { $argv0 == "-y" || $argv0 == "--agree_to_license" || $argv0 == "--batch" } {
        set ::argv [lreplace $::argv 0 0]
    } else {
        if { ![file exists $::env(HOME)/.IAgreeToSlicersLicense] } {

            if { [catch "package require Tk"] } {
                puts "\n$msg"
                puts -nonewline "Agree? \[Hit Enter for \"Ok\"\] "
                flush stdout
                gets stdin line
                if { $line != "" } {
                    set resp "cancel"
                } else {
                    set resp "ok"
                }
            } else {
                wm withdraw .
                set resp [tk_messageBox -message $msg -type okcancel -title "Slicer3"]
            }

            if {$resp == "cancel"} {
                exit
            }
        }
    }
}

#
# helper proc to handle text coming from the child process
#
proc launch_FileEvent {fp} {
    global ::END
    if {[eof $fp]} {
        set ret [catch "close $fp" res]
        set ::saved_errorCode $::errorCode
        set ::saved_errorInfo $::errorInfo
        set ::saved_result $res
        set ::saved_return $ret
        set ::END 1
    } else {
        gets $fp line
        catch {puts $line}
    }
}

#
# run the actual program 
# - check for a --launch argument for a replacement main app, otherwise run Slicer3-real
# - process the arguments to adjust the escape characters
# - launch the main app as a child process and monitor the stdout and return codes
#
proc launch_RunProgram {} {


    # 
    # look for launcher-specific arguments
    #  --launch <program>
    # or 
    #  --launch-script <script.tcl>
    #
    set launch_command ""
    set argv0 [lindex $::argv 0]
    set argv1 [lindex $::argv 1]
    switch -- $argv0 {
      "--launch" {
        if { $argv1 == "" } {
          error "--launch requires argument of program to run"
        } else {
            set launch_command $argv1
            set ::argv [lreplace $::argv 0 1]
        }
      }
      "--launch-script" {
        uplevel #0 source $argv1
        exit
      }
    }



    #
    # change from tcl escape to shell escape for command line arguments 
    # that contain spaces -- note that shell notation only works for a single
    # level of nesting
    # - change backslashes to forward slashes (for windows paths)
    # - escape the spaces in each of the arguments
    # - then remove the curly braces
    #
    regsub -all "\\\\" $::argv "/" ::argv
    set newargv ""
    foreach a $::argv {
        regsub -all " " $a "\\\ " a
        lappend newargv $a
    }
    set ::argv $newargv


    #
    # launch the slicer main script as a sub-process and monitor the output
    # - process is started with the 'open' command through a pipe
    # - the file_event callback is triggered when subprocess has written to stdout
    # - pipe is closed when process exits, causing launcher to exit too.
    #
    # why? well, some messages only go to console stdout and we don't want to lose them.
    # Also, on windows if you block waiting for the process to exit the launcher would
    # be "Not Responding" and things like screen savers and power management might not 
    # work right.
    #

    # 
    # determine the correct arguments and executable for the platform
    #
    if { $launch_command == "" } {
        if {$::env(BUILD) == $::WINDOWS} {
            set launch_command $::SLICER_HOME/bin/$::BUILD_SUBDIR/Slicer3-real.exe
        } else {
            # turn curly braces into quotes
            regsub -all "{|}" $::argv "\\\"" ::argv
            set launch_command $::SLICER_HOME/bin/Slicer3-real
        }
    }

    set ::errorInfo ""  ;# reset error info so we are sure to get errors from the 
                         # launch and not leftovers from previous 'catch' calls

    if {$::env(BUILD) == $::WINDOWS} {
        set fp [open "| \"$launch_command\" $::argv" r]
    } else {
        set fp [open "| csh -f -c \"$launch_command $::argv \" |& cat" r]
    }

    #
    # now go into a loop waiting for the child process
    # - the launch_FileEvent handles output from the child and
    #   also detects when the child exits and sets global variables
    #   to handle the return code
    #
    fileevent $fp readable "launch_FileEvent $fp"
    set ::END 0
    while { ![catch "pid $fp"] && ![eof $fp] } {
        vwait ::END
    }

    #
    # get the actual exit code of the child process
    #
    # strip the tcl stack information from the end of the errorInfo string
    set index [string last "    while executing" $::saved_errorInfo]
    set result ""
    if { $index != -1 } {
      set result [string range $::saved_errorInfo 0 $index]
    }

    set codeString [lindex $::saved_errorCode 0]
    switch $codeString {
      "NONE" { 
        set code 0 
      }
      "CHILDKILLED" {
        set code 1
        set result "$result\n$::saved_errorCode"
      }
      "CHILDSTATUS" {
        set code [lindex $::saved_errorCode 2] 
      }
      default {
        set code -1
        set result "Exceptional errorCode: $::saved_errorCode\n$::saved_errorInfo"
      }
    }

    if { $result != "" } {
      puts $result
    }
    exit $code
}

######
#######  The actual steps for launching:
######

launch_InitEnvironment 

launch_SetPaths 

launch_SplashScreen

# - no licenseDialog needed for Slicer3
#launch_LicenseDialog

#
# run program until it exits and then exit this script with the ouput
#
launch_RunProgram
