#!/bin/sh
# the next line restarts using tclsh \
    exec wish "$0" "$@"


#
# launch.tcl
#
# This script is used to set platform-specific variables for the shell
# that will be used to launch slicer.
#
# - what platform you're on so correct libs are loaded
# - what modules are present so they can be loaded
# - set all PATH, LD_LIBRARY_PATH, TCLLIBPATH, and other shell-level
#   variables to reflect that state
#   
# This is a tcl script rather than a .bat or .sh file so it can handle all 
# the details in one place for all platforms.
#
# This script is used for both the slicer build directory and for the slicer
# install directory.
#
# Note: the version of this file called launch.tcl.in will be configured by 
# cmake such that tokens between @ signs will be replaced by the variable 
# from the cmake cache
#
 

#
# SLICER_HOME: , find it relative to the location of this script
# -- when run by the launcher, this variable will be set already
# -- this environment variable can be relied on by slicer code to know "where it lives"
#    e.g. the build or install dir, so resources and other files can be found
#
set wd [pwd]
cd [file dirname [file dirname [info script]]]
set ::SLICER_HOME [pwd]
cd $wd
set ::env(SLICER_HOME) $::SLICER_HOME

if { [string match -nocase "windows*" $::tcl_platform(os)] } {
  set ::SLICER_HOME [file attributes $::SLICER_HOME -shortname]
  set ::env(SLICER_HOME) $::SLICER_HOME
}

#
# set up variables for the OS Builds
# 
set ::SOLARIS "solaris8"
set ::LINUX "linux-x86"
set ::LINUX_64 "linux-x86_64"
set ::DARWIN "darwin-ppc"
set ::DARWIN_X86 "darwin-x86"
set ::WINDOWS "win32"

#
# set the default locations for the main components
#
switch $::tcl_platform(os) {
    "SunOS" { set ::env(BUILD) $::SOLARIS }
    "Linux" {           
        if {$::tcl_platform(machine) == "x86_64"} {
            set ::env(BUILD) $::LINUX_64 
        } else {
            set ::env(BUILD) $::LINUX
        }
    }       
    "Darwin" { 
        if {$::tcl_platform(machine) == "i386"} {
            set ::env(BUILD) $::DARWIN_X86
        } else {
            set ::env(BUILD) $::DARWIN 
        }
    }
    default { 
        set ::env(BUILD) $::WINDOWS 
    }
}

#
# check if this is an install or a build directory
# - an install will have a copy of vtk in the bin directory
# - a build dirctory will not
#
set installed 0
set ext ""
if { [string match -nocase "windows*" $::tcl_platform(os)] } {
  set ext ".exe"
}

if { [file exists $::env(SLICER_HOME)/bin/vtk$ext] } {
  set installed 1
}

# for windows builds there's an extra subdir like "Debug" or "RelWithDebInfo"
# (it doesn't exist once the program has been installed)
set ::BUILD_SUBDIR  ""
if { !$installed && [string match -nocase "windows*" $::tcl_platform(os)] } {
  set ::BUILD_SUBDIR  @CMAKE_BUILD_TYPE@
}

if { $installed } {

  # if installed, everything is in the local tree
  set ::SLICER3_REAL $::SLICER_HOME/bin/Slicer3-real$ext
  set ::env(VTK_DIR)           $::env(SLICER_HOME)/lib
  set ::env(VTK_BIN_DIR)       $::env(SLICER_HOME)/bin
  set ::env(KWWidgets_DIR)     $::env(SLICER_HOME)/lib/KWWidgets
  set ::env(KWWidgets_LIB_DIR) $::env(SLICER_HOME)/lib/KWWidgets
  set ::env(KWWidgets_BIN_DIR) $::env(SLICER_HOME)/bin
  set ::env(ITK_BIN_DIR)       $::env(SLICER_HOME)/lib/InsightToolkit
  set ::env(SANDBOX_BIN_DIR)   ""
  set ::env(TCL_LIBRARY)       $::env(SLICER_HOME)/lib/Slicer3/tcl/lib
  set ::env(TCL_DIR)           $::env(SLICER_HOME)/lib/Slicer3/tcl
  set ::env(TEEM_DIR)          $::env(SLICER_HOME)/lib/TEEM-1-9
  set ::env(MRML_DIR)          $::env(SLICER_HOME)/lib/MRML
  set ::env(PARSER_DIR)        $::env(SLICER_HOME)/lib/ModuleDescriptionParser
  set ::env(SLICER_LIB_DIR)    $::env(SLICER_HOME)/lib/Slicer3

  set ::env(SLICER_BIN_DIR)    $::env(SLICER_HOME)/bin

} else {

  #
  # not installed, 
  # set variables using cmake configuration info
  # - if CMAKE_BUILD_TYPE not set, look for build type
  #
  if {$::env(BUILD) == $::WINDOWS} {
    if { $::BUILD_SUBDIR != "" } {
      set ::SLICER3_REAL $::SLICER_HOME/bin/$::BUILD_SUBDIR/Slicer3-real.exe
    } else {
      foreach buildType {Debug RelWithDebInfo Release MinSizeRel} {
        set ::SLICER3_REAL $::SLICER_HOME/bin/$buildType/Slicer3-real.exe
        if { [file exists $::SLICER3_REAL] } {
          set ::BUILD_SUBDIR $buildType
          break;
        }
      }
    }
  } else {
    set ::SLICER3_REAL $::SLICER_HOME/bin/Slicer3-real
  }
  set ::env(VTK_DIR)           [file normalize "@VTK_DIR@"]
  set ::env(VTK_BIN_DIR)       [file normalize "@VTK_DIR@/bin/$::BUILD_SUBDIR"]
  set ::env(KWWidgets_DIR)     [file normalize "@KWWidgets_DIR@"]
  set ::env(KWWidgets_LIB_DIR) [file normalize "@KWWidgets_DIR@/bin/$::BUILD_SUBDIR"]
  set ::env(KWWidgets_BIN_DIR) [file normalize "@KWWidgets_DIR@/bin/$::BUILD_SUBDIR"]
  set ::env(ITK_BIN_DIR)       [file normalize "@ITK_DIR@/bin/$::BUILD_SUBDIR"]
  set ::env(SANDBOX_BIN_DIR)   ""
  set ::env(TCL_LIBRARY)       [file normalize "@TCL_LIBRARY@"]
  set ::env(TCL_DIR)           [file normalize [file dirname [file dirname $::env(TCL_LIBRARY)]]]
  set ::env(TEEM_DIR)          [file normalize "@TEEM_DIR@/bin/$::BUILD_SUBDIR"]
  set ::env(SLICER_BIN_DIR)    [file normalize "@LIBRARY_OUTPUT_PATH@/$::BUILD_SUBDIR"]
  set ::env(SLICER_LIB_DIR)    [file normalize "@LIBRARY_OUTPUT_PATH@/$::BUILD_SUBDIR"]
  set ::env(MRML_DIR)          [file normalize "@LIBRARY_OUTPUT_PATH@/$::BUILD_SUBDIR"]
  set ::env(PARSER_DIR)        [file normalize "@LIBRARY_OUTPUT_PATH@/$::BUILD_SUBDIR"]

}

set ::env(SLICER_VERSION)    @Slicer3_VERSION_PATCH@


proc launch_ParseArgs {argv} {

  set ::LAUNCH(showSplash) 1
  set ::LAUNCH(launchCommand) ""
  set ::LAUNCH(detach) 0

  # 
  # look for launcher-specific arguments
  #  --launch <program>
  # or 
  #  --launch-script <script.tcl>
  #    (this is a special case that runs the script
  #     in this interp and then exits)
  #
  #  --detach to run the command without monitoring the stdio
  #
  # and obey --no-splash, but don't swallow it (pass it on to slicer)
  #

  set argv0 [lindex $::argv 0]
  set argv1 [lindex $::argv 1]
  switch -- $argv0 {
    "--launch" {
      if { $argv1 == "" } {
        error "--launch requires argument of program to run"
      } else {
          set ::LAUNCH(launchCommand) $argv1
          regsub -all "\\\\" $::LAUNCH(launchCommand) "/" ::LAUNCH(launchCommand)
          set ::argv [lreplace $::argv 0 1]

          # don't show splash if running a custom command
          set ::LAUNCH(showSplash) 0
      }
    }
    "--launch-script" {
      set ::argv [lreplace $::argv 0 1]
      uplevel #0 source $argv1
      exit
    }
  }

  # check for the arguments
  set newargs ""
  foreach arg $::argv {
    switch -- $arg {
      "--help" -
      "-h" -
      "--no_splash" -
      "--no-splash" {
          set ::LAUNCH(showSplash) 0
          lappend newargs $arg ;# pass arg to Slicer3-real
      }
      "--detach" {
        set ::LAUNCH(detach) 1
      }
      default {
        # escape any pipe characters 
        regsub -all "\\|" $arg "\\\\|" arg
        lappend newargs $arg
      }
    }
  }
  set ::argv $newargs
}

proc launch_InitEnvironment {} {

  foreach var {LD_LIBRARY_PATH TCLLIBPATH DYLD_LIBRARY_PATH PATH} {
    # if it is an empty string or doesn't exist, set the environment variable
    if { ![info exists ::env($var)] || $::env($var) == "" } {
        set ::env($var) " "
    }
  }
}


proc launch_SetPaths {} {
    #
    # add the necessary library directories, both Base and Modules, to the 
    # LD_LIBRARY_PATH environment variable
    #
    #
    # set the base library paths for this build 
    # 
    if {$::env(BUILD) == $::SOLARIS ||
        $::env(BUILD) == $::LINUX_64 || 
        $::env(BUILD) == $::LINUX} {
        # add vtk, slicer, and tcl bins
            set ::env(LD_LIBRARY_PATH) $::env(VTK_BIN_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(KWWidgets_LIB_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(ITK_BIN_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(TCL_DIR)/lib:$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(TEEM_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(MRML_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(VTK_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(PARSER_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(LD_LIBRARY_PATH) $::env(SLICER_LIB_DIR):$::env(LD_LIBRARY_PATH)
            set ::env(PATH) "$::env(PATH):$::env(TEEM_DIR)"
            set ::env(PATH) "$::env(SLICER_BIN_DIR):$::env(PATH)"
            set ::env(PATH) "$::SLICER_HOME/lib/Slicer3/Plugins:$::env(PATH)"
        } elseif {$::env(BUILD) ==  $::DARWIN || $::env(BUILD) == $::DARWIN_X86} { 
            # add vtk, slicer, and tcl bins
            set ::env(DYLD_LIBRARY_PATH) $::env(VTK_BIN_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(KWWidgets_LIB_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(ITK_BIN_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(TCL_DIR)/lib:$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(TEEM_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(MRML_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(VTK_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(PARSER_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(DYLD_LIBRARY_PATH) $::env(SLICER_LIB_DIR):$::env(DYLD_LIBRARY_PATH)
            set ::env(PATH) $::env(PATH):$::env(TEEM_DIR)
            set ::env(PATH) "$::env(SLICER_BIN_DIR):$::env(PATH)"
            set ::env(PATH) "$::SLICER_HOME/lib/Slicer3/Plugins:$::env(PATH)"
        } elseif {$::env(BUILD) == $::WINDOWS} {
            # add vtk, slicer, and tcl bins
            set ::env(Path) $::env(VTK_BIN_DIR)\;$::env(Path)
            set ::env(Path) $::env(KWWidgets_BIN_DIR)\;$::env(Path)
            set ::env(Path) $::env(ITK_BIN_DIR)\;$::env(Path)
            set ::env(Path) $::env(TCL_DIR)/bin\;$::env(Path)
            set ::env(Path) $::env(TEEM_DIR)\;$::env(Path)
            set ::env(Path) $::env(MRML_DIR)\;$::env(Path)
            set ::env(Path) $::env(VTK_DIR)\;$::env(Path)
            set ::env(Path) $::env(PARSER_DIR)\;$::env(Path)
            set ::env(Path) $::env(SLICER_BIN_DIR)\;$::env(Path)
            set ::env(Path) $::env(SLICER_LIB_DIR)\;$::env(Path)
        } else {
            puts stderr "Libraries: unknown build $::env(BUILD)"
        }

    # set the base tcl/tk library paths, using the previously defined TCL_LIB_DIR
    set ::env(TCL_LIBRARY) $::env(TCL_DIR)/lib/tcl8.4
    set ::env(TK_LIBRARY) $::env(TCL_DIR)/lib/tk8.4

    #
    # add the default search locations for tcl packages
    #
    set ::env(TCLLIBPATH) "$::env(VTK_DIR)/Wrapping/Tcl $::env(TCLLIBPATH)"
    set ::env(TCLLIBPATH) "$::env(KWWidgets_DIR)/Wrapping/Tcl $::env(TCLLIBPATH)"
    set ::env(TCLLIBPATH) "$::env(SLICER_HOME)/Base/Wrapping/Tcl/vtkSlicerBase $::env(TCLLIBPATH)"
    set ::env(TCLLIBPATH) "$::env(TCL_DIR)/lib/itcl3.2 $::env(TCLLIBPATH)"
    set ::env(TCLLIBPATH) "$::env(TCL_DIR)/lib/itk3.2 $::env(TCLLIBPATH)"
    set ::env(TCLLIBPATH) "$::env(TCL_DIR)/lib/iwidgets4.0.1 $::env(TCLLIBPATH)"
    set ::env(TCLLIBPATH) "$::env(TCL_DIR)/lib/blt2.4 $::env(TCLLIBPATH)"
}

#
# optional - show splash screen
#
proc launch_SplashScreen {} {

  if { $::LAUNCH(showSplash) } {

    if { [catch "package require Tk"] } {
      # if we can't open Tk, there's 
      puts "\nWarning: cannot open DISPLAY.  This is likely to be an X Server issue."
      puts "Slicer will attempt to launch, but may fail.\n"
      set $::LAUNCH(showSplash) 0
      return
    }

    wm withdraw .
    launch_SplashShow
  }
  
  # windows always has a display, so get rid of the default window
  if { [string match -nocase "windows*" $::tcl_platform(os)] } {
    wm withdraw .
  }
}


#-------------------------------------------------------------------------------
# .PROC SplashKill
# Release the application grab on the splash window, destroy the window, and delete the image.
# .ARGS
# .END
#-------------------------------------------------------------------------------
proc launch_SplashKill {} { 

    # because this is called from bgerror, don't cause any errors 
    if {[info command .splash] != ""} {
        # release the grab
        grab release .splash
        destroy .splash
    }
}

proc launch_SplashAnimate { {delayms 100} } {
  if {[info command .splash] != ""} {
    set dots [.splash.v cget -text]
    if { $dots == "**********" } { 
      set dots "*" 
    } else {
      set dots *$dots
    }
    .splash.v configure -text $dots
    update
    after $delayms "launch_SplashAnimate $delayms"
  }
}

#-------------------------------------------------------------------------------
# .PROC SplashShow
# Builds and displays a splash screen, .splash
# .ARGS
# int delayms how long to show the splash screen, defaults to 7000, in milliseconds
# .END
#-------------------------------------------------------------------------------
proc launch_SplashShow { {delayms 7000} } {

    set oscaling [tk scaling]
    # ignore screen based default scaling and pick scale so words show up nicely inside box
    tk scaling 1.5
    set width 500
    set height 200
    set splashfont [font create -family Helvetica -size 10]
    set splashfontb [font create -family Helvetica -size 10 -weight bold]
    toplevel .splash -relief raised -borderwidth 6 -width $width -height $height -bg white
    wm overrideredirect .splash 1
    set xcorner [expr [winfo screenwidth .splash]/2-($width/2)]
    set ycorner [expr [winfo screenheight .splash]/2-($height/2)]
    wm geometry .splash +$xcorner+$ycorner

    label .splash.t1 -text "Slicer3 starting up..." -bg white -font $splashfontb
    label .splash.t2 -text "" -bg white -fg red -font $splashfont
    label .splash.v -text "" -bg white -fg darkblue -font $splashfont

    place .splash.t1 -relx 0.5 -rely 0.30 -anchor center
    #place .splash.t2 -relx 0.5 -rely 0.50 -anchor center
    place .splash.v -relx 0.5 -rely 0.60 -anchor center
    update

    after 100 "launch_SplashAnimate 300" 

    bind .splash <1> launch_SplashKill
    after 10000 launch_SplashKill
    tk scaling $oscaling
}


proc launch_puts {args} {
  if { [catch "puts [list $args]" res] } {
    puts $res
  }
}

#
# helper proc to handle text coming from the child process
#
set ::count 0
proc launch_FileEvent {fp} {
    if {[eof $fp]} {
        set ret [catch "close $fp" res]
        set ::saved_errorCode $::errorCode
        set ::saved_errorInfo $::errorInfo
        set ::saved_result $res
        set ::saved_return $ret
        set ::END 1
    } else {
        gets $fp line
        puts $line
        launch_SplashKill ;# just in case the pre-splash screen is still up
    }
}

#
# run the actual program 
# - check for a --launch argument for a replacement main app, otherwise run Slicer3-real
# - process the arguments to adjust the escape characters
# - launch the main app as a child process and monitor the stdout and return codes
#
proc launch_RunProgram {} {

    #
    # change from tcl escape to shell escape for command line arguments 
    # that contain spaces -- note that shell notation only works for a single
    # level of nesting
    # - change backslashes to forward slashes (for windows paths)
    # - escape the spaces in each of the arguments
    # - handle any escaped | where the \ was changed to / by mistake
    #
    regsub -all "\\\\" $::argv "/" ::argv
    regsub -all "/\\|" $::argv "\\\\|" ::argv
    set newargv ""
    foreach a $::argv {
        regsub -all " " $a "\\\ " a
        lappend newargv $a
    }
    set ::argv $newargv

    if {$::env(BUILD) != $::WINDOWS} {
      # turn curly braces into quotes
      regsub -all "{|}" $::argv "\\\"" ::argv
    }


    #
    # launch the slicer main script as a sub-process and monitor the output
    # - process is started with the 'open' command through a pipe
    # - the file_event callback is triggered when subprocess has written to stdout
    # - pipe is closed when process exits, causing launcher to exit too.
    #
    # why? well, some messages only go to console stdout and we don't want to lose them.
    # Also, on windows if you block waiting for the process to exit the launcher would
    # be "Not Responding" and things like screen savers and power management might not 
    # work right.
    #

    # 
    # determine the correct arguments and executable for the platform
    #
    if { $::LAUNCH(launchCommand) == "" } {
      set ::LAUNCH(launchCommand) $::SLICER3_REAL
    }

    set ::errorInfo ""  ;# reset error info so we are sure to get errors from the 
                         # launch and not leftovers from previous 'catch' calls

    # detach mode: start the executable and then go away
    if { $::LAUNCH(detach) } {
        exec $::LAUNCH(launchCommand) $::argv &
        exit
    }

    if {$::env(BUILD) == $::WINDOWS} {
        set fp [open "| \"$::LAUNCH(launchCommand)\" $::argv" r]
    } else {
        set fp [open "| sh -c \"$::LAUNCH(launchCommand) $::argv \" |& cat" r]
    }

    #
    # now go into a loop waiting for the child process
    # - the launch_FileEvent handles output from the child and
    #   also detects when the child exits and sets global variables
    #   to handle the return code
    #
    fileevent $fp readable "launch_FileEvent $fp"
    set ::END 0
    while { ![catch "pid $fp"] && ![eof $fp] } {
        vwait ::END
    }

    #
    # get the actual exit code of the child process
    #
    # strip the tcl stack information from the end of the errorInfo string
    set index [string last "    while executing" $::saved_errorInfo]
    set result ""
    if { $index != -1 } {
      set result [string range $::saved_errorInfo 0 $index]
    }

    set codeString [lindex $::saved_errorCode 0]
    switch $codeString {
      "" -
      "NONE" { 
        set code 0 
      }
      "CHILDKILLED" {
        set code 1
        set result "$result\n$::saved_errorCode"
      }
      "CHILDSTATUS" {
        set code [lindex $::saved_errorCode 2] 
      }
      default {
        set code -1
        set result "Exceptional errorCode: $::saved_errorCode, $::saved_errorCode\n$::saved_errorInfo"
      }
    }

    if { $result != "" } {
      puts $result
    }
    exit $code
}

######
#######  The actual steps for launching:
######

launch_ParseArgs $argv 

launch_SplashScreen

launch_InitEnvironment 

launch_SetPaths 


#
# run program until it exits and then exit this script with the ouput
#
launch_RunProgram
